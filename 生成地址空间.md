#三种地址生成方式和限制

首先明确这里的地址，指的是代码跳转时的目标地址。根据它们在物理内存中的`相对位置和`绝对位置是否确定，它的生成有3种方式。

##编译时

在编译时写死，一般用于专用机器。这种方式得到的程序，绝对位置是确定的(当然相对位置也是确定的)。这种方式对于编程上来说有着极大的限制，
程序之间会互相干扰。但是这种方式比较安全，专用的机器和不需要跑应用程序的机器可以使用这种方法。例如以前的手机或者计算器。

##加载时

程序加载时，由于在编译期间无法确定程序加载到内存的哪一段连续的空间，所以只能标注一个相对的偏移，当加载程序的时候，根据程序加载到
的那块内存的首地址来修改偏移，偏移加上基址得到代码在内存的地址。这种方式得到的程序，相对位置是确定的，而绝对位置是可变的。

###相关问题

+ 什么是程序的加载？

程序加载到内存时（以linux为例），涉及到两个操作，使用2个工具，linker和loader。
这个过程有点类似bootloader的行为，根据elf文件确定程序的代码段和数据段，将其映射到内存中。
这个时候会重定位地址，如果是静态重定位，那么这一次重定位会根据重定位表确定所有的地址，在运行时不再改变。
如果是动态重定位，则会涉及到下一个问题的内容。

这个问题的参考资料：

http://blog.csdn.net/hmsiwtv/article/details/8198826

http://baike.baidu.com/link?url=lsepR_l6bygBVA5nqpaPa_4-hj9rbGEFqLc7gHdteBianAu26mCAwU31QHa37_FHgCD9ycNJnYxxroVCcYE7y_

+ 什么是可重定位表？

编译时会维护一个可重定位表，表中每一项是需要重定位的地址，在加载程序的时候根据可重定位表把那些地址加上这段程序的起始地址。
这个表的存在可以支持程序更好的重定位（比如效率）。

##运行时

程序在编译时，加载时都不能确定。这种情况是由于程序不仅绝对位置不能确定，相对位置也难以确定。

###相关问题

+ 为何要运行时确定？

+ 如何实现？

