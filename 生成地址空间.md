#三种地址生成方式和限制

首先明确这里的地址，指的是代码跳转时的目标地址。根据它们在物理内存中的`相对位置`和`绝对位置`是否确定，它的生成有3种方式。

##编译时

在编译时写死，一般用于专用机器。这种方式得到的程序，绝对位置是确定的(当然相对位置也是确定的)。这种方式对于编程上来说有着极大的限制，
程序之间会互相干扰。但是这种方式比较安全，专用的机器和不需要跑应用程序的机器可以使用这种方法。例如以前的手机或者计算器。

##加载时

程序加载时，由于在编译期间无法确定程序加载到内存的哪一段连续的空间，所以只能标注一个相对的偏移，当加载程序的时候，根据程序加载到
的那块内存的首地址来修改偏移，偏移加上基址得到代码在内存的地址。这种方式得到的程序，相对位置是确定的，而绝对位置是可变的。

###相关问题

+ 什么是程序的加载？

程序加载到内存时（以linux为例），涉及到两个操作，使用2个工具，linker和loader。
这个过程有点类似bootloader的行为，根据elf文件确定程序的代码段和数据段，将其映射到内存中。
这个时候会重定位地址，如果是静态重定位，那么这一次重定位会根据重定位表确定所有的地址，在运行时不再改变。
如果是动态重定位，则会涉及到下一个问题的内容。

加载时还涉及到链接的问题，这也是课堂上所讨论到的。由另一位同学整理。

这个问题的参考资料：

http://blog.csdn.net/hmsiwtv/article/details/8198826

http://baike.baidu.com/link?url=lsepR_l6bygBVA5nqpaPa_4-hj9rbGEFqLc7gHdteBianAu26mCAwU31QHa37_FHgCD9ycNJnYxxroVCcYE7y_

+ 什么是可重定位表？

编译时会维护一个可重定位表，表中每一项是需要重定位的地址，在加载程序的时候根据可重定位表把那些地址加上这段程序的起始地址。
这个表的存在可以支持程序更好的重定位（比如效率）。

##运行时

这种情况是由于程序不仅绝对位置不能确定，相对位置也难以确定。是因为程序没有一次性加载完，每次只加载运行时需要的那一部分程序。
这样可以节省内存空间，但程序会存放在不连续的物理内存中。这需要我们的硬件和操作系统实现页式存储管理，这需要MMU的支持。

刚才提到了程序的加载，这种情况下，是使用动态重定位。

###相关问题

+ 为何要运行时确定？

> 1.首先，运行时确定意味着加载时不需要一次性把代码全部加载入内存，节省内存空间。

> 2.其次，如果使用动态链接库来共享代码段，则必须使用这种方法。

> 3.使得程序中某个模块的修改不需要重新编译整个程序（有可能很大），编译时只需要修改少量的部分即可。

+ 如何实现？

需要结合虚拟存储来实现。使用页式内存管理，创建一段虚拟空间和代码以及库对应，但是不一定分配物理内存（每次需要用到时才会分配）。